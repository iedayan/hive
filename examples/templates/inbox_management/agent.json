{
  "agent": {
    "id": "inbox_management",
    "name": "Inbox Management",
    "version": "1.0.0",
    "description": "Automatically triage unread Gmail emails using user-defined free-text rules. Fetch unread emails (configurable batch size, default 100), classify each by urgency and type, then take appropriate actions \u2014 trash spam, archive low-priority messages, mark important emails, and categorize the rest as Action Needed, FYI, or Waiting On."
  },
  "graph": {
    "id": "inbox_management-graph",
    "goal_id": "inbox-management",
    "version": "1.0.0",
    "entry_node": "intake",
    "entry_points": {
      "start": "intake"
    },
    "pause_nodes": [],
    "terminal_nodes": [
      "report"
    ],
    "nodes": [
      {
        "id": "intake",
        "name": "Intake",
        "description": "Receive and validate input parameters: rules and max_emails. Present the interpreted rules back to the user for confirmation.",
        "node_type": "event_loop",
        "input_keys": [
          "rules",
          "max_emails"
        ],
        "output_keys": [
          "rules",
          "max_emails"
        ],
        "nullable_output_keys": [],
        "input_schema": {},
        "output_schema": {},
        "system_prompt": "You are an inbox management assistant. The user has provided rules for managing their emails.\n\n**STEP 1 \u2014 Respond to the user (text only, NO tool calls):**\n\nRead the user's rules from the input context. Present a clear summary of what you will do with their emails based on their rules.\n\nThe following Gmail actions are available \u2014 map the user's rules to whichever apply:\n- **Trash** emails\n- **Mark as spam**\n- **Mark as important** / unmark important\n- **Mark as read** / mark as unread\n- **Star** / unstar emails\n- **Add/remove Gmail labels** (INBOX, UNREAD, IMPORTANT, STARRED, SPAM, CATEGORY_PERSONAL, CATEGORY_SOCIAL, CATEGORY_PROMOTIONS, CATEGORY_UPDATES, CATEGORY_FORUMS)\n\nPresent the rules back to the user in plain language. Do NOT refuse rules \u2014 if the user asks for any of the above actions, confirm you will do it.\n\nAlso confirm the batch size (max_emails). If max_emails is not provided, default to 100.\n\nAsk the user to confirm: \"Does this look right? I'll proceed once you confirm.\"\n\n**STEP 2 \u2014 After the user confirms, call set_output:**\n\n- set_output(\"rules\", <the confirmed rules as a clear text description>)\n- set_output(\"max_emails\", <the confirmed max_emails as a string number, e.g. \"100\">)",
        "tools": [],
        "model": null,
        "function": null,
        "routes": {},
        "max_retries": 3,
        "retry_on": [],
        "max_node_visits": 1,
        "output_model": null,
        "max_validation_retries": 2,
        "client_facing": true,
        "success_criteria": null
      },
      {
        "id": "fetch-emails",
        "name": "Fetch Emails",
        "description": "Fetch emails from the Gmail inbox up to the configured batch limit. Pure Python function \u2014 calls Gmail API directly via httpx, writes compact JSONL to session data_dir.",
        "node_type": "function",
        "input_keys": [
          "rules",
          "max_emails"
        ],
        "output_keys": [
          "emails"
        ],
        "nullable_output_keys": [],
        "input_schema": {},
        "output_schema": {},
        "system_prompt": "You are an inbox management assistant. Your job is to fetch unread emails from Gmail and save each one to a file immediately after fetching it.\n\n**IMPORTANT CONSTRAINTS:**\n- ONLY fetch emails that are UNREAD. Use the query \"is:unread\" with gmail_list_messages.\n- Fetch at most the number specified in max_emails (from context).\n- Use the \"id\" field (NOT \"threadId\") from gmail_list_messages results when calling gmail_get_message. These are different values.\n\n**PROCESS \u2014 SAVE EACH EMAIL IMMEDIATELY:**\n1. Call gmail_list_messages with query \"is:unread\" and max_results set to max_emails (cap at 50 per call).\n2. For each message in the results:\n   a. Call gmail_get_message(message_id=<the \"id\" field>) to get full details.\n   b. If the message returns an error, skip it and continue.\n   c. Check if the result was TOO LARGE and spilled to a file (the result will say \"too large for context, saved to '<filename>'\"). If so:\n      - Call load_data(filename=<the spilled filename>) to retrieve the full email content.\n      - Then call append_data(filename=\"emails.jsonl\", data=<the full content from load_data>) to save it.\n   d. If the result was NOT spilled (you can see the full email JSON directly), call append_data(filename=\"emails.jsonl\", data=<JSON string of this single email>) to save it.\n   Do NOT try to collect emails in memory. Save each one right after fetching it.\n3. If there are more results (next_page_token is present) and you haven't reached max_emails, call gmail_list_messages again with the page_token.\n4. After all emails are fetched and saved, call set_output(\"emails\", \"emails.jsonl\").\n\n**CRITICAL:**\n- Pass ONLY the filename \"emails.jsonl\" to set_output, NOT the email data itself. The data is already saved to the file.\n- Each append_data call saves one email as a single JSON line (JSONL format). When using content from load_data, collapse it to a single line before appending.\n- If there are no unread emails, call set_output(\"emails\", \"[]\").",
        "tools": [],
        "model": null,
        "function": null,
        "routes": {},
        "max_retries": 3,
        "retry_on": [],
        "max_node_visits": 1,
        "output_model": null,
        "max_validation_retries": 2,
        "client_facing": false,
        "success_criteria": null
      },
      {
        "id": "classify-and-act",
        "name": "Classify and Act",
        "description": "Apply the user's rules to each email and execute the appropriate Gmail actions.",
        "node_type": "event_loop",
        "input_keys": [
          "rules",
          "emails"
        ],
        "output_keys": [
          "actions_taken"
        ],
        "nullable_output_keys": [],
        "input_schema": {},
        "output_schema": {},
        "system_prompt": "You are an inbox management assistant. Your job is to apply the user's rules to their emails and execute the appropriate Gmail actions.\n\n**IMPORTANT: The emails have ALREADY been fetched and saved to a local file.** You do NOT need to fetch emails from Gmail. Use the `load_data` tool to read them.\n\n**RULES** are provided in the context as \"rules\".\n**EMAILS** are provided as a filename in the context as \"emails\" (e.g. \"emails.jsonl\"). Each line is a compact JSON object with keys: id, subject, from, to, date, snippet, labels.\n\n**STEP 1 \u2014 LOAD EMAILS:**\nCall load_data(filename=<the \"emails\" value from context>, limit=10) to load the first page of emails.\n- If the file is empty or has no lines, call set_output(\"actions_taken\", \"no emails to process\") and stop.\n\n**STEP 2 \u2014 ANALYZE THE RULES:**\nNow that you can see the emails, determine your strategy:\n\n- **Blanket rule** (same action for ALL emails, e.g. \"mark all as unread\", \"archive everything\"): No per-email classification needed. Collect all message IDs across all pages, then execute ONE batch operation.\n- **Classification rule** (different actions for different emails, e.g. \"trash spam, star important\"): Classify each email based on subject, from, and snippet.\n\n**STEP 3 \u2014 EXECUTE ACTIONS:**\n\nIF BLANKET RULE:\n1. Collect ALL message IDs from the loaded page. If has_more=true, load more pages with load_data(offset=..., limit=10) until all IDs collected.\n2. Execute ONE gmail_batch_modify_messages call with all IDs.\n3. Record each action with append_data(filename=\"actions.jsonl\", data=<JSON of {email_id, subject, from, action}>).\n\nIF CLASSIFICATION RULE:\n1. For each email on the current page, classify based on subject, from, and snippet.\n2. Group emails by action (e.g. all \"trash\" together, all \"star\" together).\n3. Execute batch operations per group \u2014 use gmail_batch_modify_messages for label changes, gmail_trash_message for trash (no batch version).\n4. Record each action with append_data(filename=\"actions.jsonl\", data=<JSON of {email_id, subject, from, action}>).\n5. If has_more=true, load next page with load_data(offset=..., limit=10) and repeat.\n\n**STEP 4 \u2014 FINISH:**\nAfter ALL pages are processed, call set_output(\"actions_taken\", \"actions.jsonl\").\n\n**AVAILABLE ACTIONS:**\n- TRASH \u2014 gmail_trash_message(message_id). No batch version; call per email.\n- MARK AS SPAM \u2014 gmail_batch_modify_messages(message_ids=[...], add_labels=[\"SPAM\"], remove_labels=[\"INBOX\"])\n- MARK IMPORTANT \u2014 gmail_batch_modify_messages(message_ids=[...], add_labels=[\"IMPORTANT\"])\n- REMOVE IMPORTANT \u2014 gmail_batch_modify_messages(message_ids=[...], remove_labels=[\"IMPORTANT\"])\n- MARK AS UNREAD \u2014 gmail_batch_modify_messages(message_ids=[...], add_labels=[\"UNREAD\"])\n- MARK AS READ \u2014 gmail_batch_modify_messages(message_ids=[...], remove_labels=[\"UNREAD\"])\n- STAR \u2014 gmail_batch_modify_messages(message_ids=[...], add_labels=[\"STARRED\"])\n- UNSTAR \u2014 gmail_batch_modify_messages(message_ids=[...], remove_labels=[\"STARRED\"])\n- ARCHIVE \u2014 gmail_batch_modify_messages(message_ids=[...], remove_labels=[\"INBOX\"])\n\n**VALID GMAIL LABELS:** INBOX, UNREAD, IMPORTANT, STARRED, SPAM, TRASH, SENT, DRAFT, CATEGORY_PERSONAL, CATEGORY_SOCIAL, CATEGORY_PROMOTIONS, CATEGORY_UPDATES, CATEGORY_FORUMS.\n\n**CRITICAL:**\n- ALWAYS prefer gmail_batch_modify_messages over gmail_modify_message.\n- Your FIRST tool call must be load_data. Do NOT skip this step.\n- Do NOT call set_output until all emails are processed.\n- Pass ONLY the filename \"actions.jsonl\" to set_output, NOT raw data.",
        "tools": [
          "gmail_trash_message",
          "gmail_modify_message",
          "gmail_batch_modify_messages",
          "load_data",
          "append_data"
        ],
        "model": null,
        "function": null,
        "routes": {},
        "max_retries": 3,
        "retry_on": [],
        "max_node_visits": 1,
        "output_model": null,
        "max_validation_retries": 2,
        "client_facing": false,
        "success_criteria": null
      },
      {
        "id": "report",
        "name": "Report",
        "description": "Generate a summary report of all actions taken on the emails.",
        "node_type": "event_loop",
        "input_keys": [
          "actions_taken"
        ],
        "output_keys": [
          "summary_report"
        ],
        "nullable_output_keys": [],
        "input_schema": {},
        "output_schema": {},
        "system_prompt": "You are an inbox management assistant. Your job is to generate a clear summary report of the actions taken on the user's emails.\n\n**LOADING ACTIONS:**\nThe \"actions_taken\" value from context is a filename (e.g. \"actions.jsonl\"), NOT raw action data.\n- If it equals \"[]\", there are no actions \u2014 generate a report stating no emails were processed and call set_output.\n- Otherwise, call load_data(filename=<the actions_taken value>) to read the action records.\n- The file is in JSONL format: each line is one JSON object with: email_id, subject, from, action.\n- If load_data returns has_more=true, call it again with the next offset to get more records.\n- Read ALL records before generating the report.\n\n**GENERATE a summary report:**\n\n1. **Overview** \u2014 Total emails processed, breakdown by action type.\n\n2. **By Action** \u2014 Group emails by action taken. For each action group, list the emails with subject and sender.\n\n3. **No Action Taken** \u2014 Any emails that didn't match any rules (if applicable).\n\nFormat the report as clean, readable text (not JSON).\n\nAfter generating the report, call:\n- set_output(\"summary_report\", <the formatted report text>)",
        "tools": [
          "load_data"
        ],
        "model": null,
        "function": null,
        "routes": {},
        "max_retries": 3,
        "retry_on": [],
        "max_node_visits": 1,
        "output_model": null,
        "max_validation_retries": 2,
        "client_facing": false,
        "success_criteria": null
      }
    ],
    "edges": [
      {
        "id": "intake-to-fetch-emails",
        "source": "intake",
        "target": "fetch-emails",
        "condition": "on_success",
        "condition_expr": null,
        "priority": 1,
        "input_mapping": {}
      },
      {
        "id": "fetch-emails-to-classify",
        "source": "fetch-emails",
        "target": "classify-and-act",
        "condition": "on_success",
        "condition_expr": null,
        "priority": 1,
        "input_mapping": {}
      },
      {
        "id": "classify-to-report",
        "source": "classify-and-act",
        "target": "report",
        "condition": "on_success",
        "condition_expr": null,
        "priority": 1,
        "input_mapping": {}
      }
    ],
    "max_steps": 100,
    "max_retries_per_node": 3,
    "description": "Automatically triage unread Gmail emails using user-defined free-text rules. Fetch unread emails (configurable batch size, default 100), classify each by urgency and type, then take appropriate actions \u2014 trash spam, archive low-priority messages, mark important emails, and categorize the rest as Action Needed, FYI, or Waiting On.",
    "created_at": "2026-02-12T18:04:05.829422"
  },
  "goal": {
    "id": "inbox-management",
    "name": "Inbox Management",
    "description": "Automatically triage unread Gmail emails using user-defined free-text rules. Fetch unread emails (configurable batch size, default 100), classify each by urgency and type, then take appropriate actions \u2014 trash spam, archive low-priority messages, mark important emails, and categorize the rest as Action Needed, FYI, or Waiting On.",
    "status": "draft",
    "success_criteria": [
      {
        "id": "email-classification-accuracy",
        "description": "Each unread email is classified according to the user's free-text rules with appropriate urgency category (action needed, FYI, waiting on) and type (spam, newsletter, important, etc.)",
        "metric": "classification_match_rate",
        "target": ">=90%",
        "weight": 0.3,
        "met": false
      },
      {
        "id": "correct-action-execution",
        "description": "Trash, archive, mark-important, and label actions are applied correctly to the right emails based on classification",
        "metric": "action_correctness",
        "target": ">=95%",
        "weight": 0.25,
        "met": false
      },
      {
        "id": "unread-only-guarantee",
        "description": "Only unread emails are fetched and processed; read emails are never modified",
        "metric": "read_email_modifications",
        "target": "0",
        "weight": 0.2,
        "met": false
      },
      {
        "id": "classification-report",
        "description": "Produces a summary report showing what was done: how many trashed, archived, marked important, and categorized, with email subjects listed per category",
        "metric": "report_completeness",
        "target": "100%",
        "weight": 0.15,
        "met": false
      },
      {
        "id": "batch-completeness",
        "description": "All fetched emails up to the configured max are classified and acted upon; none are silently skipped",
        "metric": "emails_processed_ratio",
        "target": "100%",
        "weight": 0.1,
        "met": false
      }
    ],
    "constraints": [
      {
        "id": "no-read-email-modification",
        "description": "Must never modify, trash, or relabel emails that are already read",
        "constraint_type": "hard",
        "category": "safety",
        "check": ""
      },
      {
        "id": "respect-batch-limit",
        "description": "Must not process more emails than the configured max_emails parameter",
        "constraint_type": "hard",
        "category": "operational",
        "check": ""
      },
      {
        "id": "non-destructive-default",
        "description": "Archiving removes from inbox but preserves the email; only explicit trash rules move emails to trash",
        "constraint_type": "hard",
        "category": "safety",
        "check": ""
      }
    ],
    "context": {},
    "required_capabilities": [],
    "input_schema": {},
    "output_schema": {},
    "version": "1.0.0",
    "parent_version": null,
    "evolution_reason": null,
    "created_at": "2026-02-12 18:03:43.084459",
    "updated_at": "2026-02-12 18:03:43.084460"
  },
  "required_tools": [
    "load_data",
    "gmail_modify_message",
    "append_data",
    "gmail_batch_modify_messages",
    "gmail_trash_message"
  ],
  "metadata": {
    "created_at": "2026-02-12T18:04:05.829661",
    "node_count": 4,
    "edge_count": 3
  }
}